# -*- coding: utf-8 -*-
"""
@author: Derk Wiersma s4897323
Github page: https://github.com/DW8030/Fabulous-Fractals-2
"""

#L-system:
    #start with A (initial string or axiom)
    #rules:
        #A is replaced with AB
        #B is replaced by A
        #iterate this for x amount times
        
import turtle
from random import randint
import time

turtle.speed(0)
turtle.tracer(0, 0) 
#lets turtle calculate the fractal before drawing for a huge speedup. 
#0, 0 means animation = off and delay = 0
                    


intro = input("""
Welcome to Fabulous Fractals 2!
Would you like to start with one of five pre-made fractals (press Q),
or would you like to generate your own (press W)?
              """)
if intro == 'Q':
    prepared_fractal = input("""
Do you want to see a Sierpinski triangle (Q),
a Dragon Curve (W),
a square fractal (E),
a Koch snowflake (R),
or a Tree (T)?
                            """)
if intro == 'W':
    own_fractal = input("""
You enter a rule as following: if you want to replace a with abba, 
you enter a, a, b, b, a, if  you want to replace b with ac, you enter b, a, c
etc.You enter the angle as following: if the fractal sequence is generated, 
and you want the cursor to turn x degrees to the right when it encounters the first 
item in the list of rule 1, you add x to angle 1. If you want to move the 
cursor forward by y pixels when it encounters the first item in the list of 
rule 1, you add y to distance 1, etc. A maximum of 5 rules are supported. 
(press enter)
                        """)
    custom_rule_1 = list(input("Enter custom rule 1: "))
    custom_rule_2 = list(input("Enter custom rule 2: "))
    custom_rule_3 = list(input("Enter custom rule 3: "))
    custom_rule_4 = list(input("Enter custom rule 4: "))
    custom_rule_5 = list(input("Enter custom rule 5: "))
    custom_angle_1= int(input("Enter custom angle 1: "))
    custom_distance_1= int(input("Enter custom distance 2: "))
    custom_angle_2= int(input("Enter custom angle 2: "))
    custom_distance_2= int(input("Enter custom length 2: "))
    custom_angle_3= int(input("Enter custom angle 3: "))
    custom_distance_3= int(input("Enter custom length 3: "))
    custom_angle_4= int(input("Enter custom angle 4: "))
    custom_distance_4= int(input("Enter custom length 4: "))
    custom_angle_5= int(input("Enter custom angle 5: "))
    custom_distance_5= int(input("Enter custom length 5: "))
    zoom_level = int(input("Enter the zoom level of the fractal: "))
    axiom = list(input("Enter the starting list (or 'axiom'): "))
bg_color = input("Enter a background color (e.g. blue): ")
pen_color = input("Enter a pen color (e.g. red) (does not affect Tree): ")
start_sign = str(input("Start? (answer yes): "))

def fractal_maker(fractal_generations, fractal_rules, fractal_drawer, fractal_list):
    """
    This function draws a fractal according to the number of fractal generations
    , the rules for generating a new generation, the way of interpreting the 
    generated according to the rules, and an initial starting list

    Parameters
    ----------
    fractal_generations : int
        the zoom level (number of generations) of the fractal.
    fractal_rules : function
        the fuction that contains the rules for generating a new generation.
    fractal_drawer : function
        the function that interprets the data in the list generated by
        fractal_rules to draw the fractal.
    fractal_list : list
        the list that contains data for generation of a new zoom level.

    Returns
    -------
    Draws fractal with turtle

    """
    for i in range(fractal_generations):
    #iterates the fuction for each zoom level
      fractal_list = fractal_rules(fractal_list)
      #updates the list according to the function
    fractal_drawer(fractal_list)
    #draws the fractal according to the data in the fractal_list
    #this function is the one that should preferably use turtle, but the user
    #is free to use something else

def custom_fractal_drawer(fractal_list):
    """
    This function takes in a list with data and uses it to draw a fractal
    with turtle according to custom_rule_1 through 5, custom_angle_1 through 5 
    and custom_distance_1 through 5.

    Parameters
    ----------
    fractal_list : list
        contains the data according to which the fractal will be drawn.

    Returns
    -------
    Draws fractal on screen.

    """
    for item in fractal_list:
        if item == custom_rule_1[0]:
        #looks if the item in the list the symbol at the first index of 
        #custom_rule_1 and if True, will perform action 
            turtle.right(custom_angle_1)
            #turns the cursor to the right by custom_angle_1 degrees
            turtle.forward(custom_distance_1)
            #moves the cursor forward by custom_distance_1 pixels
        if item == custom_rule_2[0]:
        #the rest works the same (putting it in a for loop didn't work)
            turtle.right(custom_angle_2)
            turtle.forward(custom_distance_2)            
        if item == custom_rule_3[0]:
            turtle.right(custom_angle_3)
            turtle.forward(custom_distance_3)
        if item == custom_rule_4[0]:
            turtle.right(custom_angle_4)
            turtle.forward(custom_distance_4)  
        if item == custom_rule_5[0]:
            turtle.right(custom_angle_5)
            turtle.forward(custom_distance_5)

            
def fractal_drawer_triangle(fractal_list):
    """
    Takes in a fractal list (generated by fractal_rules_triangle) to draw a 
    Sierpinski triangle with turtle

    Parameters
    ----------
    fractal_list : list
        contains the data according to which the fractal will be drawn.

    Returns
    -------
    Draws fractal with turtle.

    """
    turtle.penup()
    turtle.goto(400, -380)
    turtle.left(180)
    turtle.pendown()
    #these steps move the cursor to a suitable position and location
    for item in fractal_list:
        #looks at every item in the fractal_list and moves the cursor according
        #to the rules below
        if item == '+':
            turtle.right(60)
            turtle.forward(3)  
        if item == '-':
            turtle.left(60)
            turtle.forward(3)  

def fractal_drawer_elephant(fractal_list):
    """
    Takes in a fractal list (generated by fractal_rules_elephant) to draw a 
    Dragon curve fractal with turtle

    Parameters
    ----------
    fractal_list : list
        contains the data according to which the fractal will be drawn.

    Returns
    -------
    Draws fractal on screen.

    """
    for i in range(2):
        turtle.penup()
        turtle.goto(0, 0)
        turtle.left(0)
        turtle.pendown()
        #moves the cursor to a suitable location and orientation
        for item in fractal_list:
        #looks at every item in the fractal_list and moves the cursor according
        #to the rules below    
            if item == '+':
                turtle.right(90)
                turtle.forward(1)  
            if item == '-':
                turtle.left(90)
                turtle.forward(1) 

def fractal_drawer_square(fractal_list):
    """
    Takes in a fractal list (generated by fractal_rules_square) to draw a 
    Dragon curve fractal with turtle.


    Parameters
    ----------
    fractal_list : list
        contains the data according to which the fractal will be drawn.

    Returns
    -------
    Draws fractal on screen.

    """
    turtle.penup()
    turtle.goto(-400, -380)
    turtle.left(0)
    turtle.pendown()
    #these steps move the cursor to a suitable position and location
    for item in fractal_list:
        #looks at every item in the fractal_list and moves the cursor according
        #to the rules below
        if item == '+':
            turtle.left(90) 
            turtle.forward(3) 
        if item == '-':
            turtle.right(90)
            turtle.forward(3) 

def fractal_drawer_snowflake(fractal_list):
    """
    Takes in a fractal list (generated by fractal_rules_snowflake) to draw a 
    Dragon curve fractal with turtle.    

    Parameters
    ----------
    fractal_list : list
        contains the data according to which the fractal will be drawn.

    Returns
    -------
    Draws fractal on screen.

    """
    turtle.penup()
    turtle.goto(-300, 150)
    turtle.left(0)
    turtle.pendown()
    for item in fractal_list:
        #looks at every item in the fractal_list and moves the cursor according
        #to the rules below
        if item == '+':
            turtle.right(60) 
            turtle.forward(2)  
        if item == '-':
            turtle.left(60)
            turtle.forward(2) 
        if item == 'a':
            turtle.forward(4)   
            
def fractal_drawer_tree(fractal_list):
    """
    Takes in a fractal list (generated by fractal_rules_Tree) to draw a 
    L-system tree with turtle.

    Parameters
    ----------
    fractal_list : list
        DESCRIPTION.

    Returns
    -------
    Draws fractal on screen.

    """
    turtle.penup()
    turtle.goto(0, -380)
    turtle.left(90)
    turtle.pendown()
    #moves the cursor to a suitable location and orientation
    branch_length = 80
    #sets the initial length of the trunk and branches to 80 pixels
    angle = lambda: randint(5, 30)
    #the angle is assigned a random value from 
    colour = [0.3, 0.0, 0.0]
    help_list = [] 
    #this help list is needed to save data in so the fractal can move back to 
    #a past point of origin
    thickness = 20
    #sets initial thickness of the trunk to 30
    turtle.pensize(thickness)
    #sets the pensize to the thickness, this is not done in one step, because
    #the thickness will be updated later
    for item in fractal_list:
        #looks at every item in the fractal_list and moves the cursor according
        #to the rules below
        turtle.color(colour)
        #changes the color of the pen
        if item == 'a' or item == 'b':
            turtle.forward(branch_length) 
            #moves the cursor forward by branch_length pixels
        if item == 'c':
            branch_length -= randint(6, 8)
            #reduces the branch length by a randomly 6 or 7 pixels
            colour[1] += 0.06
            #increases the intensity of the green color (which has index 1 in
            #the rgb code) in the pen color by 6%
            if thickness > 8:
                thickness -= 2
            turtle.pensize(thickness)
            #changes the thickness of the pen by 3 if larger than 8
        if item == '+':
            turtle.right(angle()) 
            #calls the angle function to turn the cursor right bya random 
            #amount degrees
        if item == '-':
            turtle.left(angle())
            #calls the angle function to turn the cursor left by a random
            #amount degrees
        if item == '[':
            help_list.append((turtle.heading(), turtle.pos(), thickness, 
                              branch_length, colour[1]))
            #appends the help_list with the direction, position, thickness of 
            #the pen and by with the current branch length and green colour 
            #intensity
        if item == ']':
            heading, position, thickness, branch_length, colour[1] = help_list.pop()
            #reads out the direction, position, thickness of the pen, as well 
            #as the last saved branch length and green colour intesity and
            #removes those from the list
            turtle.penup()
            turtle.pensize(thickness)
            #alters pensize
            turtle.goto(position) 
            #moves pen to the desired position
            turtle.setheading(heading)
            #turns the cursor towards the right direction
            turtle.pendown()
            #the pen is adjusted according to the data

def custom_fractal_rules(fractal_list):
    """
    Takes in a fractal list and updates it according to custom_rule_1 through 5
    to generate a new generation of the fractal
    

    Parameters
    ----------
    fractal_list : list
        contains the data for the fractal that will be used to generate a 
        new generation.

    Returns
    -------
    new_fractal_list : list
        contains the data for the new generation of fractal.

    """
    new_fractal_list = []
    #make a new list
    for item in fractal_list:
    #looks at all items in the list
        if item == custom_rule_1[0]:
            #looks if the item is the same as the first item in custom_rule_1
            new_fractal_list.extend(custom_rule_1[1:])
            #if True, the new list will be extended by the rest of the items in
            #custom_rule_1
        if item == custom_rule_2[0]:
            #the rest workd the same (using a for loop didn't work)
            new_fractal_list.extend(custom_rule_2[1:])
        if item == custom_rule_3[0]:
            new_fractal_list.extend(custom_rule_3[1:])
        if item == custom_rule_4[0]:
            new_fractal_list.extend(custom_rule_4[1:])  
        if item == custom_rule_5[0]:
            new_fractal_list.extend(custom_rule_5[1:])          
    return new_fractal_list
        
def fractal_rules_triangle(fractal_list):
    """
    Takes in a fractal list and updates it according to the rules below to 
    generate a new generation of the fractal

    Parameters
    ----------
    fractal_list : list
        contains the data for the fractal that will be used to generate a 
        new generation.

    Returns
    -------
    new_fractal_list : list
        contains the data for the new generation of fractal.

    """
    new_fractal_list = []
    #creates new list
    for item in fractal_list: 
        #looks at every item in the list and extends the new list
        #according to the rules below
        if item == '+':
            new_fractal_list.extend(['+'])
        if item == '-':
            new_fractal_list.extend(['-'])
        if item == 'a':
            new_fractal_list.extend(['b', '-', 'a', '-', 'b'])    
        if item == 'b':
            new_fractal_list.extend(['a', '+', 'b', '+', 'a'])      
    return new_fractal_list

def fractal_rules_elephant(fractal_list):
    """
    Takes in a fractal list and updates it according to the rules below to 
    generate a new generation of the fractal

    Parameters
    ----------
    fractal_list : list
        contains the data for the fractal that will be used to generate a 
        new generation.

    Returns
    -------
    new_fractal_list : list
        contains the data for the new generation of fractal.

    """
    new_fractal_list = []
    #creates new list
    for item in fractal_list: 
        #looks at every item in the list and extends the new list
        #according to the rules below
        if item == '+':
            new_fractal_list.extend(['+'])
        if item == '-':
            new_fractal_list.extend(['-'])  
        if item == 'a':
            new_fractal_list.extend(['a', '+', 'b', '+'])    
        if item == 'b':
            new_fractal_list.extend(['-', 'a', '-', 'b']) 
    return new_fractal_list

def fractal_rules_square(fractal_list):
    """
    Takes in a fractal list and updates it according to the rules below to 
    generate a new generation of the fractal

    Parameters
    ----------
    fractal_list : list
        contains the data for the fractal that will be used to generate a 
        new generation.

    Returns
    -------
    new_fractal_list : list
        contains the data for the new generation of fractal.

    """
    #this shoul produce a Hilbert curve, but apparently it does not.
    new_fractal_list = []
    #creates new list
    for item in fractal_list: 
        #looks at every item in the list and extends the new list
        #according to the rules below
        if item == '+':
            new_fractal_list.extend(['+'])
        if item == '-':
            new_fractal_list.extend(['-'])
        if item == 'a':
            new_fractal_list.extend(['+', 'b', '-', 'a', 'a', '-', 'b', '+'])    
        if item == 'b':
            new_fractal_list.extend(['-', 'a', '+', 'b', 'b', '+', 'a', '-'])      
    return new_fractal_list

def fractal_rules_snowflake(fractal_list):
    """
    Takes in a fractal list and updates it according to the rules below to 
    generate a new generation of the fractal

    Parameters
    ----------
    fractal_list : list
        contains the data for the fractal that will be used to generate a 
        new generation.

    Returns
    -------
    new_fractal_list : list
        contains the data for the new generation of fractal.

    """
    new_fractal_list = []
    #creates new list
    for item in fractal_list: 
        #looks at every item in the list and extends the new list
        #according to the rules below
        if item == '+':
            new_fractal_list.extend(['+'])
        if item == '-':
            new_fractal_list.extend(['-'])
        if item == 'a':
            new_fractal_list.extend(['a', '-', 'a', '+', '+', 'a', '-', 'a'])
    return new_fractal_list

def fractal_rules_tree(fractal_list):
    """
    Takes in a fractal list and updates it according to the rules below to 
    generate a new generation of the fractal

    Parameters
    ----------
    fractal_list : list
        contains the data for the fractal that will be used to generate a 
        new generation.

    Returns
    -------
    new_fractal_list : list
        contains the data for the new generation of fractal.

    """
    new_fractal_list = []
    #creates new list
    for item in fractal_list: 
        #looks at every item in the list and extends the new list
        #according to the rules below
        if item == '+':
            new_fractal_list.extend(['+'])
        if item == '-':
            new_fractal_list.extend(['-'])
        if item == '[':
            new_fractal_list.extend(['['])
        if item == ']':
            new_fractal_list.extend([']'])         
        if item == 'a':
            new_fractal_list.extend(['b', '[', 'c', '[', '-', 'a', ']', '+', 'a', ']'])  
        if item == 'b':
            new_fractal_list.extend(['b'])  
        if item == 'c':
            new_fractal_list.extend(['c'])     
    return new_fractal_list

    
def main(bg_color, pen_color, start_sign, intro, prepared_fractal):
    """
    Draws a fractal according to the user input.
    

    Parameters
    ----------
    bg_color : str
        background color for turtle.
    pen_color : str
        pen color for turtle.
    start_sign : str
        a confirmation to start the fractal.
    intro : str
        the result of the intro question.
    prepared_fractal : str
        a letter to denote which of the prepared fractals to run.

    Returns
    -------
    Draws fractal on screen.

    """
    turtle.bgcolor(bg_color)
    turtle.pencolor(pen_color)
    if start_sign == 'yes':
        start_time = time.perf_counter()
        if intro == 'Q':
            if prepared_fractal == 'Q':
                fractal_maker(8, fractal_rules_triangle, 
                              fractal_drawer_triangle, ['a'])
            if prepared_fractal == 'W':
                fractal_maker(16, fractal_rules_elephant, 
                              fractal_drawer_elephant, ['a'])
            if prepared_fractal == 'E': 
                fractal_maker(7, fractal_rules_square, 
                              fractal_drawer_square, ['a'])
            if prepared_fractal == 'R': 
                fractal_maker(4, 
                              fractal_rules_snowflake, 
                              fractal_drawer_snowflake, 
                              ['a', '+', '+', 'a', '+', '+', 'a'])
            if prepared_fractal == 'T': 
                fractal_maker(12, fractal_rules_tree, 
                              fractal_drawer_tree, ['x'])
        if intro == 'W':
                    fractal_maker(zoom_level, custom_fractal_rules, 
                                  custom_fractal_drawer, axiom)        
    turtle.update()
    print("Execution time: %s seconds " % (time.perf_counter() - start_time))
    turtle.done()


if __name__ == '__main__': 
    main(bg_color, pen_color, start_sign, intro, prepared_fractal='Q')


